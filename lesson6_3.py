'''
Сформируйте два словаря из случайных букв в качестве ключа и случайных чисел в качестве значений.

dict_1 = {'a': 1, 'b': 2, 'c': 3, ....}

dict_2 = {'z': 1, 'x': 9, 'c': 6, ....}

Сформируйте новый словарь из двух существующих:

Если в исходных словарях есть повторяющиеся ключи, выбираем среди их значений максимальное и присваиваем этому ключу
(например, в словаре_1 есть ключ “а” со значением 5, и в словаре_2 есть ключ “а”, но со значением 9. Выбираем
максимальное значение, т. е. 9, и присваиваем ключу “а” в уже новом словаре).

Если ключ не повторяется, то он просто переносится со своим значением в новый словарь (например, ключ “с” встретился
только у одного словаря, а у других его нет. Следовательно, переносим в новый словарь этот ключ вместе с его значением).
Сформированный словарь возвращаем.
'''

dict_1 = {'a': 7, 'b': 8, 'n': 9, 'o': 15, 'p': 11, 'q': 4}
dict_2 = {'c': 5, 'd': 6, 'n': 13, 'o': 12, 'p': 6, 'q': 10}
dict_3 = dict_1 | dict_2

for k, v in dict_3.items():
    if k in dict_1.keys():
        v = dict_1[k] if v < dict_3[k] else v
    dict_3[k] = v

print(dict_1)
print(dict_2)
print(dict_3)



# Зато смог сделать решение с помощью функции, но тут получается без создания третьего словаря
# from collections import Counter
# from functools import reduce
#
# my_dict_1 = {'a': 7, 'b': 8, 'n': 9, 'o': 15, 'p': 11, 'q': 16}
# my_dict_2 = {'c': 5, 'd': 6, 'n': 13, 'o': 12, 'p': 6, 'q': 10}
#
# def max_dct(*dicts):
#     return dict(reduce(lambda a, b: Counter(a) | Counter(b), dicts))
#
# print(my_dict_1)
# print(my_dict_2)
# print(max_dct(my_dict_1, my_dict_2))
